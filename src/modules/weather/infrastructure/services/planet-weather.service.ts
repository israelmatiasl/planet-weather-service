import { Inject, Injectable } from "@nestjs/common";
import { WeatherClient } from "../http/weather.client";
import { SwapiClient } from "../http/swapi.client";
import { PlanetWeather } from "../../domain/planet-weather.entity";
import { LocationUtil } from "../../../../shared/location.util";
import { PlanetWeatherRepository } from "../persistence/planet-weather.repository";

@Injectable()
export class PlanetWeatherService {
    constructor(
        private readonly weatherClient: WeatherClient,
        private readonly swapiClient: SwapiClient,
        @Inject('PlanetWeatherRepository')
        private readonly repository: PlanetWeatherRepository
    ) {}

    public async getFusedPlanetWeather(latitude?: number, longitude?: number): Promise<PlanetWeather> {

        const weatherData = await this.weatherClient.getWeatherByLocation(latitude, longitude);

        const planetId = this.calculatePlanetMatch(weatherData);

        const planet = await this.swapiClient.getPlanetById(planetId);

        const planetWeather = PlanetWeather.create({
            location: LocationUtil.getLocationName(weatherData.latitude, weatherData.longitude),
            temperature: weatherData.current.temperature_2m,
            humidity: weatherData.current.relative_humidity_2m,
            planetName: planet.name,
            planetClimate: planet.climate,
            matchScore: this.calculateMatchScore(),
            autogenerated: 1,
        });

        await this.repository.save(planetWeather);

        return planetWeather;
    }

    public async savePlanetWeather(data: any): Promise<PlanetWeather> {
        const planetWeather = PlanetWeather.create({
            location: data.location,
            temperature: data.temperature,
            humidity: data.humidity,
            planetName: data.planetName,
            planetClimate: data.planetClimate,
            matchScore: this.calculateMatchScore(),
            autogenerated: 0,
        });

        await this.repository.save(planetWeather);
        return planetWeather;
    }

    public async getAllPlanetWeather(
        autogenerated: boolean = false,
        limit: number = 10,
        lastKey?: string
    ): Promise<{ items: PlanetWeather[]; lastKey?: Record<string, any>; lastKeyString?: string }> {
        let lastKeyObj: Record<string, any> | undefined = undefined;
        if (lastKey) {
            try {
                lastKeyObj = JSON.parse(Buffer.from(lastKey, 'base64').toString('utf-8'));
            } catch {
                lastKeyObj = undefined;
            }
        }
        const { items, lastKey: newLastKey } = await this.repository.findByAutogenerated(autogenerated, limit, lastKeyObj);
        return {
            items,
            lastKey: newLastKey,
            lastKeyString: newLastKey ? Buffer.from(JSON.stringify(newLastKey)).toString('base64') : undefined,
        };
    }

    private calculatePlanetMatch(weatherData) : number {
        const temp = weatherData.current.temperature_2m;
        const humidity = weatherData.current.relative_humidity_2m;
        const precipitation = weatherData.daily.precipitation_sum[0];
        
        if (temp > 30 && humidity < 40 && precipitation < 1) {
            return 1;
        } else if (temp < 5 || precipitation > 20) {
            return 4;
        } else if (humidity > 80 || precipitation > 10) {
            return 10;
        } else if (temp >= 15 && temp <= 25 && humidity >= 50 && humidity <= 75) {
            return 8;
        } else if (temp > 25 && humidity > 60) {
            return 7;
        } else {
            return 2;
        }
    }

     private calculateMatchScore(): number {
        return Math.round(Math.random() * 100);
    }
}